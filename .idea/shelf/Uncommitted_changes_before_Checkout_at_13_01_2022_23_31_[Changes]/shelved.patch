Index: Magic_Minerals.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport sys\r\nimport os\r\n\r\npygame.init()\r\nFPS = 50\r\nWIDTH = 1080\r\nHEIGHT = 720\r\nSTEP = 10\r\n\r\nfirst_time = True\r\nvictory = False\r\n\r\n# группы спрайтов\r\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\r\npygame.display.set_caption('Magic Minerals')\r\nclock = pygame.time.Clock()\r\n\r\nall_sprites = pygame.sprite.Group()\r\nanimated_group = pygame.sprite.Group()\r\nstones_group = pygame.sprite.Group()\r\nnecessary_stones = []  # список необходимых камней (объектов класса NecessaryStone)\r\nnecessary_stones_group = pygame.sprite.Group()\r\ninstruments_group = pygame.sprite.Group()\r\n\r\nloaded_images = {}\r\n\r\n\r\ndef load_image(name,  directory='stones', color_key=None):\r\n    full_name = os.path.join(directory, name)\r\n    if full_name not in loaded_images.keys():\r\n        try:\r\n            image = pygame.image.load(full_name)\r\n        except pygame.error as message:\r\n            print(f'В папке отсутствует файл {name}')\r\n            raise SystemExit(message)\r\n\r\n        if color_key is not None:\r\n            if color_key == -1:\r\n                color_key = image.get_at((0, 0))\r\n            image.set_colorkey(color_key)\r\n        else:\r\n            image = image.convert_alpha()\r\n        loaded_images[full_name] = image\r\n        return image\r\n    else:\r\n        return loaded_images[full_name]\r\n\r\n\r\ndef load_level(filename):\r\n    filename = os.path.join('stones', filename)\r\n    # читаем уровень, убирая символы перевода строки\r\n    with open(filename, 'r') as mapFile:\r\n        level_map = [line.strip() for line in mapFile]\r\n\r\n    # и подсчитываем максимальную длину\r\n    max_width = max(map(len, level_map))\r\n\r\n    # дополняем каждую строку пустыми клетками ('.')\r\n    return list(map(lambda x: x.ljust(max_width, '.'), level_map))\r\n\r\n\r\ndef generate_level(level):\r\n    x, y = None, None\r\n    for y in range(len(level)):\r\n        for x in range(len(level[y])):\r\n            Stone(level[y][x], x, y)\r\n    return x, y\r\n\r\n\r\ndef terminate():\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\n\r\ndef draw_cell_field():\r\n    board.render(screen)\r\n    stones_group.draw(screen)\r\n    # animated_group.draw(screen)\r\n    # animated_group.update()\r\n    # [b.kill() for b in animated_group]\r\n\r\n\r\ndef draw_instruments():\r\n    pygame.draw.rect(screen, pygame.Color('brown'), (630, 130, 90, 360), 0)\r\n    pygame.draw.rect(screen, pygame.Color('wheat'), (630, 130, 90, 360), 3)\r\n    for i in range(4):\r\n        Instrument(instruments[i], 0, i)\r\n    instruments_group.draw(screen)\r\n\r\n\r\ndef to_statistic(stone_num, quantity):\r\n    for st in necessary_stones:\r\n        if st.tile_type == stone_num:\r\n            st.text[0] += quantity\r\n\r\n\r\ndef write_statistic(*stones):\r\n    text = ''\r\n    x, y = 0, 8\r\n    coeff = 10\r\n    global first_time\r\n    if first_time:\r\n        for stone in stones:\r\n            st = NecessaryStone(stone[0], x, y, stone[1])\r\n            necessary_stones.append(st)\r\n            text += ' ' * coeff + f'0/{stone[1]}'\r\n            x += 2\r\n            coeff = 19\r\n            first_time = False\r\n    else:\r\n        for stone in necessary_stones:\r\n            text += ' ' * coeff + f'{stone.text[0]}/{stone.text[1]}'\r\n            x += 2\r\n            coeff = 19\r\n    text = [text]\r\n    font = pygame.font.Font(None, 30)\r\n    text_coord = 650\r\n    necessary_stones_group.draw(screen)\r\n    for line in text:\r\n        string_rendered = font.render(line, 1, pygame.Color('white'))\r\n        text_rect = string_rendered.get_rect()\r\n        text_coord += 10\r\n        text_rect.top = text_coord\r\n        text_rect.x = 10\r\n        text_coord += text_rect.height\r\n        screen.blit(string_rendered, text_rect)\r\n    count = 0\r\n    for stone in necessary_stones:\r\n        if stone.text[0] >= stone.text[1]:\r\n            count += 1\r\n    if count == len(necessary_stones):\r\n        game_result.victory()\r\n\r\n\r\nstone_images = {\r\n    '1': load_image('amber.png'),\r\n    '2': load_image('amethyst.png'), '3': load_image('diamond.png'),\r\n    '4': load_image('emerald.png'), '5': load_image('ruby.png'),\r\n    '6': load_image('sapphire.png'),\r\n}\r\n\r\ninstruments = ['pickaxe', 'drill', 'dynamite', 'lantern']\r\ninstrument_images = {}\r\n\r\nfor i in range(1, 7):\r\n    stone_images[str(i)] = pygame.transform.scale(stone_images[str(i)], (75, 75))\r\n\r\nfor ins in instruments:\r\n    instrument_images[ins] = load_image(f'{ins}.png', directory='assets/instruments')\r\n    instrument_images[ins] = pygame.transform.scale(instrument_images[ins], (90, 90))\r\n\r\n\r\ntile_width = tile_height = 75\r\n\r\n\r\nclass Board:\r\n    def __init__(self, width, height,\r\n                 left=10, top=10, cell_size=30):\r\n        self.width = width\r\n        self.height = height\r\n        self.board = load_level('level.txt')\r\n        self.cell_size = cell_size\r\n        self.left = left\r\n        self.top = top\r\n        self.c1 = (None, None)\r\n        self.c2 = (None, None)\r\n        with open('stones/fall.txt', 'rt') as f:\r\n            file = f.readlines()\r\n        self.queue = list(file[0])\r\n        self.global_del_list = []\r\n\r\n    def next_in_queue(self):\r\n        next = self.queue[0]\r\n        del self.queue[0]\r\n        return next\r\n\r\n    def set_view(self, left, top, cell_size):\r\n        self.left = left\r\n        self.top = top\r\n        self.cell_size = cell_size\r\n\r\n    def render(self, screen):\r\n        for y in range(self.height):\r\n            for x in range(self.width):\r\n                if (x, y) == self.c1:\r\n                    pygame.draw.rect(screen, pygame.Color('lightgreen'),\r\n                                     (self.left + self.c1[0] * self.cell_size,\r\n                                      self.top + self.c1[1] * self.cell_size, self.cell_size, self.cell_size), 0)\r\n                if (x, y) == self.c2:\r\n                    pygame.draw.rect(screen, pygame.Color('pink'),\r\n                                     (self.left + self.c2[0] * self.cell_size,\r\n                                      self.top + self.c2[1] * self.cell_size, self.cell_size, self.cell_size), 0)\r\n                pygame.draw.rect(screen, pygame.Color('white'),\r\n                                 (self.left + x * self.cell_size,\r\n                                  self.top + y * self.cell_size,\r\n                                  self.cell_size, self.cell_size), 1)\r\n\r\n        for lst in self.global_del_list:\r\n            for x, y in lst:\r\n                pygame.draw.rect(screen, pygame.Color('Khaki'),\r\n                                 (self.left + y * self.cell_size,\r\n                                  self.top + x * self.cell_size, self.cell_size, self.cell_size), 0)\r\n                boom = AnimatedSprite(load_image(\"boom.jpg\"), 6, 5, x * self.cell_size, y * self.cell_size)\r\n\r\n    def on_click(self, cell):\r\n        self.global_del_list = []\r\n        if self.c1 == (None, None) and self.c2 == (None, None):\r\n            self.c1 = cell\r\n        elif self.c1 != (None, None) and self.c2 == (None, None):\r\n            self.c2 = cell\r\n        else:\r\n            self.c1 = cell\r\n            self.c2 = (None, None)\r\n        if self.c1 != (None, None) and self.c2 != (None, None) and self.c1 != self.c2:\r\n            [st.kill() for st in stones_group]\r\n            c1, c2 = self.c1, self.c2\r\n            # for i, st in enumerate(stones_group):\r\n            #     if i == c1[0] * 8 + c1[1]:\r\n            #         st.kill()\r\n            #     if i == c2[0] * 8 + c2[1]:\r\n            #         st.kill()\r\n            if c1[1] == c2[1] and abs(c1[0] - c2[0]) == 1:\r\n                line1 = list(self.board[c1[1]])\r\n                stone1, stone2 = line1[c1[0]], line1[c2[0]]\r\n                if c1[0] < c2[0]:\r\n                    del line1[c1[0]]\r\n                    del line1[c2[0] - 1]\r\n                    line1.insert(c2[0] - 1, stone1)\r\n                    line1.insert(c1[0], stone2)\r\n                else:\r\n                    del line1[c2[0]]\r\n                    del line1[c1[0] - 1]\r\n                    line1.insert(c1[0] - 1, stone2)\r\n                    line1.insert(c2[0], stone1)\r\n                line1 = ''.join(line1)\r\n                self.board[self.c1[1]] = line1\r\n                self.horizontal_reduce()\r\n                self.vertical_reduce()\r\n            elif c1[0] == c2[0] and abs(c1[1] - c2[1]) == 1:\r\n                line1, line2 = list(self.board[c1[1]]), list(self.board[c2[1]])\r\n                stone1, stone2 = line1[c1[0]], line2[c2[0]]\r\n                del line1[c1[0]]\r\n                del line2[c2[0]]\r\n                line1.insert(c2[0], stone2)\r\n                line2.insert(c1[0], stone1)\r\n                line1, line2 = ''.join(line1), ''.join(line2)\r\n                self.board[c1[1]], self.board[c2[1]] = line1, line2\r\n                self.horizontal_reduce()\r\n                self.vertical_reduce()\r\n            move_pad.minus()\r\n\r\n    def get_cell(self, mouse_pos):\r\n        cell_x = (mouse_pos[0] - self.left) // self.cell_size\r\n        cell_y = (mouse_pos[1] - self.top) // self.cell_size\r\n        if cell_x < 0 or cell_x >= self.width or cell_y < 0 or cell_y >= self.height:\r\n            return None\r\n        return cell_x, cell_y\r\n\r\n    def get_click(self, mouse_pos):\r\n        cell = self.get_cell(mouse_pos)\r\n        if cell:\r\n            self.on_click(cell)\r\n\r\n    def horizontal_reduce(self):\r\n        i, j = 0, 0\r\n        while i < self.height:\r\n            del_list = []\r\n            while j < self.width:\r\n                cur_st = self.board[i][j]\r\n                del_list.append((i, j))\r\n                j += 1\r\n                if j == self.width:\r\n                    break\r\n                if self.board[i][j] == cur_st:\r\n                    while self.board[i][j] == cur_st:\r\n                        del_list.append((i, j))\r\n                        j += 1\r\n                        if j == self.width:\r\n                            break\r\n                    if len(del_list) >= 3:\r\n                        to_statistic(cur_st, len(del_list))\r\n                else:\r\n                    cur_st = self.board[i][j]\r\n                    del_list = []\r\n                if len(del_list) >= 3:\r\n                    self.global_del_list.append(del_list)\r\n                    tmp_line = list(self.board[i])\r\n                    for tpl in del_list:\r\n                        tmp_line[tpl[1]] = self.next_in_queue()\r\n                    tmp_line = ''.join(tmp_line)\r\n                    self.board[i] = tmp_line\r\n                    del_list = []\r\n            i += 1\r\n            j = 0\r\n\r\n    def vertical_reduce(self):\r\n        i, j = 0, 0\r\n        while j < self.height:\r\n            del_list = []\r\n            while i < self.width:\r\n                cur_st = self.board[i][j]\r\n                del_list.append((i, j))\r\n                i += 1\r\n                if i == self.height:\r\n                    break\r\n                if self.board[i][j] == cur_st:\r\n                    while self.board[i][j] == cur_st:\r\n                        del_list.append((i, j))\r\n                        i += 1\r\n                        if i == self.height:\r\n                            break\r\n                    if len(del_list) >= 3:\r\n                        to_statistic(cur_st, len(del_list))\r\n                else:\r\n                    cur_st = self.board[i][j]\r\n                    del_list = []\r\n                if len(del_list) >= 3:\r\n                    # tmp_line = list(self.board[i])\r\n                    self.global_del_list.append(del_list)\r\n                    for tpl in del_list:\r\n                        tmp_line = list(self.board[tpl[0]])\r\n                        tmp_line[tpl[1]] = self.next_in_queue()\r\n                        tmp_line = ''.join(tmp_line)\r\n                        self.board[tpl[0]] = tmp_line\r\n                    del_list = []\r\n            j += 1\r\n            i = 0\r\n\r\n\r\nclass AnimatedSprite(pygame.sprite.Sprite):\r\n    def __init__(self, sheet, columns, rows, x, y):\r\n        super().__init__(animated_group)\r\n        self.frames = []\r\n        self.cut_sheet(sheet, columns, rows)\r\n        self.cur_frame = 0\r\n        self.image = self.frames[self.cur_frame]\r\n        self.rect = self.rect.move(x, y)\r\n\r\n    def cut_sheet(self, sheet, columns, rows):\r\n        self.rect = pygame.Rect(0, 0, sheet.get_width() // columns,\r\n                                sheet.get_height() // rows)\r\n        for j in range(rows):\r\n            for i in range(columns):\r\n                frame_location = (self.rect.w * i, self.rect.h * j)\r\n                self.frames.append(sheet.subsurface(pygame.Rect(\r\n                    frame_location, self.rect.size)))\r\n\r\n    def update(self):\r\n        self.cur_frame = (self.cur_frame + 1) % len(self.frames)\r\n        self.image = self.frames[self.cur_frame]\r\n\r\n\r\nclass Stone(pygame.sprite.Sprite):\r\n    def __init__(self, tile_type, pos_x, pos_y):\r\n        super().__init__(stones_group, all_sprites)\r\n        self.image = stone_images[tile_type]\r\n        self.rect = self.image.get_rect().move(\r\n            10 + tile_width * pos_x, 10 + tile_height * pos_y)\r\n\r\n\r\nclass NecessaryStone(pygame.sprite.Sprite):\r\n    def __init__(self, tile_type, pos_x, pos_y, need):\r\n        super().__init__(necessary_stones_group, all_sprites)\r\n        self.tile_type = tile_type\r\n        self.image = stone_images[tile_type]\r\n        self.text = [0, need]\r\n        self.rect = self.image.get_rect().move(\r\n            10 + tile_width * pos_x, 10 + tile_height * pos_y)\r\n\r\n\r\nclass Instrument(pygame.sprite.Sprite):\r\n    def __init__(self, tile_type, pos_x, pos_y):\r\n        super().__init__(instruments_group, all_sprites)\r\n        self.image = instrument_images[tile_type]\r\n        self.rect = self.image.get_rect().move(\r\n            630, 130 + 90 * pos_y)\r\n\r\n\r\nclass Move:\r\n    def __init__(self, n):\r\n        self.n = n\r\n\r\n    def minus(self):\r\n        self.n -= 1\r\n\r\n    def show(self):\r\n        pygame.draw.ellipse(screen, 'YellowGreen', (630, 10, 90, 90), 0)\r\n        pygame.draw.ellipse(screen, 'DarkGreen', (630, 10, 90, 90), 5)\r\n        text = [str(self.n).rjust(2, ' ')]\r\n        font = pygame.font.Font(None, 70)\r\n        text_coord = 17\r\n        for line in text:\r\n            string_rendered = font.render(line, 1, pygame.Color('DarkGreen'))\r\n            text_rect = string_rendered.get_rect()\r\n            text_coord += 10\r\n            text_rect.top = text_coord\r\n            text_rect.x = 645\r\n            text_coord += text_rect.height\r\n            screen.blit(string_rendered, text_rect)\r\n\r\n\r\nclass WinOrDefeat:\r\n    def __init__(self, moves):\r\n        self.moves = moves\r\n\r\n    def check_moves(self):\r\n        if self.moves == 0 and not victory:\r\n            self.defeat()\r\n\r\n    def defeat(self):\r\n        text = 'Неудача!'\r\n        font = pygame.font.Font(None, 200)\r\n        text_coord = 17\r\n        string_rendered = font.render(text, 1, pygame.Color('White'))\r\n        text_rect = string_rendered.get_rect()\r\n        text_rect.top = text_coord\r\n        text_rect.x = 10\r\n        screen.blit(string_rendered, text_rect)\r\n\r\n    def victory(self):\r\n        global victory\r\n        text = 'Изумительно!' if self.moves < 3 else 'Прелестно!'\r\n        font = pygame.font.Font(None, 200)\r\n        text_coord = 17\r\n        string_rendered = font.render(text, 1, pygame.Color('White'))\r\n        text_rect = string_rendered.get_rect()\r\n        text_rect.top = text_coord\r\n        text_rect.x = 10\r\n        screen.blit(string_rendered, text_rect)\r\n        victory = True\r\n\r\n\r\nboard = Board(8, 8, 10, 10, 75)\r\nmove_pad = Move(20)\r\nrunning = True\r\nwhile running:\r\n    game_result = WinOrDefeat(move_pad.n)\r\n    level_x, level_y = generate_level(board.board)\r\n    for event in pygame.event.get():\r\n        if event.type == pygame.QUIT:\r\n            running = False\r\n        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:\r\n            board.get_click(event.pos)\r\n    board.horizontal_reduce()\r\n    board.vertical_reduce()\r\n    draw_cell_field()\r\n    draw_instruments()\r\n    move_pad.show()\r\n    write_statistic(('5', 10), ('6', 15), ('4', 20))\r\n    game_result.check_moves()\r\n    pygame.display.flip()\r\n    screen.fill('black')\r\n    clock.tick(FPS)\r\nterminate()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Magic_Minerals.py b/Magic_Minerals.py
--- a/Magic_Minerals.py	(revision 32bd879b907b0c5e57f25d1cf224cfd7cdadef1f)
+++ b/Magic_Minerals.py	(date 1642095030430)
@@ -3,13 +3,15 @@
 import os
 
 pygame.init()
-FPS = 50
+FPS = 15
 WIDTH = 1080
 HEIGHT = 720
 STEP = 10
 
 first_time = True
+first_time_in_ore = True
 victory = False
+double_stones_in_ores = True
 
 # группы спрайтов
 screen = pygame.display.set_mode((WIDTH, HEIGHT))
@@ -18,15 +20,19 @@
 
 all_sprites = pygame.sprite.Group()
 animated_group = pygame.sprite.Group()
+checkmark_group = pygame.sprite.Group()
 stones_group = pygame.sprite.Group()
-necessary_stones = []  # список необходимых камней (объектов класса NecessaryStone)
+fon_sprites = pygame.sprite.Group()
+necessary_stones = [] # список необходимых камней (объектов класса NecessaryStone)
 necessary_stones_group = pygame.sprite.Group()
 instruments_group = pygame.sprite.Group()
 
 loaded_images = {}
 
+all_sprites.add(pygame.sprite.Sprite())
+
 
-def load_image(name,  directory='stones', color_key=None):
+def load_image(name, directory='stones', color_key=None):
     full_name = os.path.join(directory, name)
     if full_name not in loaded_images.keys():
         try:
@@ -74,18 +80,27 @@
 
 
 def draw_cell_field():
+    fon_sprites.draw(screen)
     board.render(screen)
     stones_group.draw(screen)
-    # animated_group.draw(screen)
-    # animated_group.update()
-    # [b.kill() for b in animated_group]
 
 
 def draw_instruments():
     pygame.draw.rect(screen, pygame.Color('brown'), (630, 130, 90, 360), 0)
     pygame.draw.rect(screen, pygame.Color('wheat'), (630, 130, 90, 360), 3)
     for i in range(4):
-        Instrument(instruments[i], 0, i)
+        pygame.draw.ellipse(screen, pygame.Color('lightsalmon'), (630, 130 + 90 * i, 90, 90), 0)
+        pygame.draw.ellipse(screen, pygame.Color('wheat'), (630, 130 + 90 * i, 90, 90), 2)
+        if first_time:
+            instrument_quadra.append(Instrument(instruments[i], 0, i))
+        else:
+            if instrument_quadra[i].active:
+                pygame.draw.ellipse(screen, pygame.Color('skyblue'), (630, 130 + 90 * i, 90, 90), 0)
+            else:
+                pygame.draw.ellipse(screen, pygame.Color('lightsalmon'), (630, 130 + 90 * i, 90, 90), 0)
+            if instrument_quadra[i].used:
+                pygame.draw.ellipse(screen, pygame.Color('red'), (630, 130 + 90 * i, 90, 90), 0)
+            pygame.draw.ellipse(screen, pygame.Color('wheat'), (630, 130 + 90 * i, 90, 90), 2)
     instruments_group.draw(screen)
 
 
@@ -97,7 +112,7 @@
 
 def write_statistic(*stones):
     text = ''
-    x, y = 0, 8
+    x, y = 1.5, 8
     coeff = 10
     global first_time
     if first_time:
@@ -113,6 +128,8 @@
             text += ' ' * coeff + f'{stone.text[0]}/{stone.text[1]}'
             x += 2
             coeff = 19
+            if stone.text[0] >= stone.text[1]:
+                cm = Checkmark(stone.x, stone.y)
     text = [text]
     font = pygame.font.Font(None, 30)
     text_coord = 650
@@ -122,7 +139,7 @@
         text_rect = string_rendered.get_rect()
         text_coord += 10
         text_rect.top = text_coord
-        text_rect.x = 10
+        text_rect.x = 130
         text_coord += text_rect.height
         screen.blit(string_rendered, text_rect)
     count = 0
@@ -137,14 +154,22 @@
     '1': load_image('amber.png'),
     '2': load_image('amethyst.png'), '3': load_image('diamond.png'),
     '4': load_image('emerald.png'), '5': load_image('ruby.png'),
-    '6': load_image('sapphire.png'),
+    '6': load_image('sapphire.png'), '7': load_image('ore_1.png'),
+    '8': load_image('ore_2.png'), '9': load_image('ore_3.png'), '$': load_image('double_stone.png')
 }
+
+instrument_animations = {'pickaxe': load_image('pikhouweel_animate.png', directory='assets/animations'),
+                         'drill': load_image('boren_animate.png', directory='assets/animations'),
+                         'dynamite': load_image('dinamite_animate.png', directory='assets/animations'),
+                         'lantern': load_image('lantern_animate.png', directory='assets/animations')}
 
 instruments = ['pickaxe', 'drill', 'dynamite', 'lantern']
 instrument_images = {}
+instrument_quadra = []
 
-for i in range(1, 7):
+for i in range(1, 10):
     stone_images[str(i)] = pygame.transform.scale(stone_images[str(i)], (75, 75))
+stone_images['$'] = pygame.transform.scale(stone_images['$'], (75, 75))
 
 for ins in instruments:
     instrument_images[ins] = load_image(f'{ins}.png', directory='assets/instruments')
@@ -165,6 +190,7 @@
         self.top = top
         self.c1 = (None, None)
         self.c2 = (None, None)
+        self.ore_coords = []
         with open('stones/fall.txt', 'rt') as f:
             file = f.readlines()
         self.queue = list(file[0])
@@ -175,35 +201,104 @@
         del self.queue[0]
         return next
 
+    def find_ores(self):
+        for y in range(self.height):
+            for x in range(self.width):
+                if self.board[y][x] == '7':
+                    self.ore_coords.append((y, x))
+
+    def check_near_ores(self, del_list):
+        for ore in self.ore_coords:
+            next_ore = False
+            for st in del_list:
+                if next_ore:
+                    break
+                if st[0] + 1 == ore[0] and st[1] == ore[1] or \
+                        st[0] -  == ore[0] and st[1] == ore[1] or \
+                        st[0] == ore[0] and st[1] + 1 == ore[1] or \
+                        st[0] == ore[0] and st[1] -  == ore[1]:
+                    o = self.board[ore[0]][ore[1]]
+                    o = str(int(o) + 1)
+                    if o == '10':
+                        if double_stones_in_ores:
+                            sym = '$'
+                        else:
+                            sym = self.next_in_queue()
+                        line = list(self.board[ore[0]])
+                        line[ore[1]] = sym
+                        self.board[[0]] = ".join(line)
+                        del self.ore_coords[self.ore_coords.index(ore)]
+                    else:
+                        line = list(self.board[ore[0]])
+                        line[ore[1]] = o
+                        self.board[[0]] = ".join(line)
+                    next_ore = True
+
     def set_view(self, left, top, cell_size):
         self.left = left
         self.top = top
         self.cell_size = cell_size
 
-    def render(self, screen):
+     defrender(self, screen):
+        global first_time_in_ore
+        if first_time_in_ore:
+            self.find_ores()
+            first_time_in_ore = False
         for y in range(self.height):
             for x in range(self.width):
-                if (x, y) == self.c1:
-                    pygame.draw.rect(screen, pygame.Color('lightgreen'),
-                                     (self.left + self.c1[0] * self.cell_size,
-                                      self.top + self.c1[1] * self.cell_size, self.cell_size, self.cell_size), 0)
-                if (x, y) == self.c2:
-                    pygame.draw.rect(screen, pygame.Color('pink'),
-                                     (self.left + self.c2[0] * self.cell_size,
-                                      self.top + self.c2[1] * self.cell_size, self.cell_size, self.cell_size), 0)
                 pygame.draw.rect(screen, pygame.Color('white'),
-                                 (self.left + x * self.cell_size,
+ (self.left + x * self.cell_size,
                                   self.top + y * self.cell_size,
                                   self.cell_size, self.cell_size), 1)
+                if self.board[y][x] in ['7', '8', '9']:
+                    pygame.draw.rect(screen, pygame.Color('yellowgreen'),
+ (self.left + x * self.cell_size,
+                                      self.top + y * self.cell_size,
+                                      self.cell_size, self.cell_size), 0)
+                if self.board[y][x] == '$':
+                    pygame.draw.rect(screen, pygame.Color('pink'),
+                                     (self.left + x * self.cell_size,
+                                      self.top + y * self.cell_size,
+                                      self.cell_size, self.cell_size), 0)
 
         for lst in self.global_del_list:
             for x, y in lst:
-                pygame.draw.rect(screen, pygame.Color('Khaki'),
-                                 (self.left + y * self.cell_size,
-                                  self.top + x * self.cell_size, self.cell_size, self.cell_size), 0)
-                boom = AnimatedSprite(load_image("boom.jpg"), 6, 5, x * self.cell_size, y * self.cell_size)
+                boom = AnimatedSprite(load_image('mineral_die_animate.png', directory='assets/animations'),
+                                      3, 1, y * self.cell_size, x * self.cell_size)
+
+    def tools_into_battle(self, cell):
+        for ins in instrument_quadra:
+            if ins.active and not ins.used:
+                an = AnimatedSprite(instrument_animations[ins.name], 6, 1,
+                                    cell[0] * self.cell_size, cell[1] * self.cell_size)
+                if ins.name == 'pickaxe' and not ins.used:
+                    to_statistic(self.board[cell[1]][cell[0]], 1)
+                    line = list(self.board[cell[1]])
+                    line[cell[0]] = self.next_in_queue()
+                    self.board[cell[1]] = ''.join(line)
+                    instrument_quadra[instruments.index(ins.name)].used = True
+                    boom = AnimatedSprite(load_image('mineral_die_animate.png', directory='assets/animations'),
+                                          3, 1, cell[0] * self.cell_size, cell[1] * self.cell_size)
+                elif ins.name == 'drill' and not ins.used:
+                    for elem in self.board[cell[1]]:
+                        to_statistic(elem, 1)
+                    line = ''
+                    for i in range(8):
+                        line += self.next_in_queue()
+                        boom = AnimatedSprite(load_image('mineral_die_animate.png', directory='assets/animations'),
+                                              3, 1, i * self.cell_size, cell[1] * self.cell_size)
+                    self.board[cell[1]] = line
+                    instrument_quadra[instruments.index(ins.name)].used = True
+                # elif ins.name
+                [st.kill() for st in stones_group]
+                self.horizontal_reduce()
+                self.vertical_reduce()
+            ins.active = False
+            self.c1, self.c2 = None, None
+        instrument_pad.active_instrument = None
 
     def on_click(self, cell):
+        self.tools_into_battle(cell)
         self.global_del_list = []
         if self.c1 == (None, None) and self.c2 == (None, None):
             self.c1 = cell
@@ -215,40 +310,64 @@
         if self.c1 != (None, None) and self.c2 != (None, None) and self.c1 != self.c2:
             [st.kill() for st in stones_group]
             c1, c2 = self.c1, self.c2
+            old_board = self.board[:]
             # for i, st in enumerate(stones_group):
             #     if i == c1[0] * 8 + c1[1]:
             #         st.kill()
             #     if i == c2[0] * 8 + c2[1]:
             #         st.kill()
-            if c1[1] == c2[1] and abs(c1[0] - c2[0]) == 1:
-                line1 = list(self.board[c1[1]])
-                stone1, stone2 = line1[c1[0]], line1[c2[0]]
-                if c1[0] < c2[0]:
-                    del line1[c1[0]]
-                    del line1[c2[0] - 1]
-                    line1.insert(c2[0] - 1, stone1)
-                    line1.insert(c1[0], stone2)
-                else:
-                    del line1[c2[0]]
-                    del line1[c1[0] - 1]
-                    line1.insert(c1[0] - 1, stone2)
-                    line1.insert(c2[0], stone1)
-                line1 = ''.join(line1)
-                self.board[self.c1[1]] = line1
-                self.horizontal_reduce()
-                self.vertical_reduce()
-            elif c1[0] == c2[0] and abs(c1[1] - c2[1]) == 1:
-                line1, line2 = list(self.board[c1[1]]), list(self.board[c2[1]])
-                stone1, stone2 = line1[c1[0]], line2[c2[0]]
-                del line1[c1[0]]
-                del line2[c2[0]]
-                line1.insert(c2[0], stone2)
-                line2.insert(c1[0], stone1)
-                line1, line2 = ''.join(line1), ''.join(line2)
-                self.board[c1[1]], self.board[c2[1]] = line1, line2
-                self.horizontal_reduce()
-                self.vertical_reduce()
-            move_pad.minus()
+            # if self.board[c1[0]][c1[1]] not in ['7', '8', '9'] and self.board[c2[0]][c2[1]] not in ['7', '8', '9']:
+            if c1 not in self.ore_coords and c2 not in self.ore_coords:
+                if c1[1] == c2[1] and abs(c1[0] - c2[0]) == 1:
+                    line1 = list(self.board[c1[1]])
+                    stone1, stone2 = line1[c1[0]], line1[c2[0]]
+                    if c1[0] < c2[0]:
+                        del line1[c1[0]]
+                        del line1[c2[0] - 1]
+                        line1.insert(c2[0] - 1, stone1)
+                        line1.insert(c1[0], stone2)
+                    else:
+                        del line1[c2[0]]
+                        del line1[c1[0] - 1]
+                        line1.insert(c1[0] - 1, stone2)
+                        line1.insert(c2[0], stone1)
+                    line1 = ''.join(line1)
+                    old_line = self.board[self.c1[1]][:]
+                    self.board[self.c1[1]] = line1
+                    # i, j = self.c1[1], 0
+                    # count = 1
+                    # cur_st = self.board[i][j]
+                    # while j < self.width:
+                    # j += 1
+                    # if j == self.width - 1:
+                    # break
+                    # if self.board[i][j] == cur_st:
+                    # while self.board[i][j] == cur_st:
+                    # count += 1
+                    # j += 1
+                    # if j == self.width - 1:
+                    # break
+                    # else:
+                    # cur_st = self.board[i][j]
+                    # if count >= 3:
+                    self.horizontal_reduce()
+                    self.vertical_reduce()
+                    # else:
+                    # self.board[self.c1[1]] = old_line
+                elif c1[0] == c2[0] and abs(c1[1] - c2[1]) == 1:
+                    line1, line2 = list(self.board[c1[1]]), list(self.board[c2[1]])
+                    stone1, stone2  line1[c1[0]], [c2[0]]
+                    del line1[c1[0]]
+                    del line2[c2[0]]
+                    line11.insert(c2[0], stone2)
+                    line22.insert(c1[0], stone1)
+                     = ''.join(), ''.join()
+                    self.board[c1[1]], self.board[c2[1]] = line1, line2
+                    self.horizontal_reduce()
+                    self.vertical_reduce()
+                move_pad.minus()
+                board.horizontal_reduce()
+                board.vertical_reduce()
 
     def get_cell(self, mouse_pos):
         cell_x = (mouse_pos[0] - self.left) // self.cell_size
@@ -262,6 +381,28 @@
         if cell:
             self.on_click(cell)
 
+    # def check_move_possibility(self, old_board):
+    # i, j = self.c1[1], 0
+    # count = 1
+    # cur_st = self.board[i][j]
+    # while j < self.width:
+    # j += 1
+    # if j == self.width - 1:
+    #             break
+    #         if self.board[i][j] == cur_st:
+    #             while self.board[i][j] == cur_st:
+    #                 count += 1
+    #                 j += 1
+    #                 if j == self.width - 1:
+    #                     break
+    #         else:
+    #             cur_st = self.board[i][j]
+    #     if count >= 3:
+    #         self.horizontal_reduce()
+    #         self.vertical_reduce()
+    #     else:
+    #         self.board = old_board
+
     def horizontal_reduce(self):
         i, j = 0, 0
         while i < self.height:
@@ -290,6 +431,7 @@
                         tmp_line[tpl[1]] = self.next_in_queue()
                     tmp_line = ''.join(tmp_line)
                     self.board[i] = tmp_line
+                    self.check_near_ores(del_list)
                     del_list = []
             i += 1
             j = 0
@@ -315,27 +457,36 @@
                 else:
                     cur_st = self.board[i][j]
                     del_list = []
-                if len(del_list) >= 3:
+                if len(del_list) >=> 3:
                     # tmp_line = list(self.board[i])
                     self.global_del_list.append(del_list)
                     for tpl in del_list:
                         tmp_line = list(self.board[tpl[0]])
                         tmp_line[tpl[1]] = self.next_in_queue()
-                        tmp_line = ''.join(tmp_line)
+                        tmp_line = ".join(tmp_line)
                         self.board[tpl[0]] = tmp_line
+                    self.check_near_ores(del_list)
                     del_list = []
             j += 1
             i = 0
 
 
+class Fon(pygame.sprite.Sprite):
+    def __init__(self):
+        super().__init__(all_sprites, fon_sprites)
+        self.image = load_image(name='bg.png', directory='assets/fon')
+        self.rect = self.image.get_rect().move(0, 0)
+
+
 class AnimatedSprite(pygame.sprite.Sprite):
     def __init__(self, sheet, columns, rows, x, y):
         super().__init__(animated_group)
         self.frames = []
         self.cut_sheet(sheet, columns, rows)
         self.cur_frame = 0
-        self.image = self.frames[self.cur_frame]
-        self.rect = self.rect.move(x, y)
+        self.image = pygame.transform.scale(self.frames[self.cur_frame], (90, 90))
+        self. = =.rect.move(x, y)
+        self.i = 0
 
     def cut_sheet(self, sheet, columns, rows):
         self.rect = pygame.Rect(0, 0, sheet.get_width() // columns,
@@ -346,9 +497,22 @@
                 self.frames.append(sheet.subsurface(pygame.Rect(
                     frame_location, self.rect.size)))
 
-    def update(self):
-        self.cur_frame = (self.cur_frame + 1) % len(self.frames)
-        self.image = self.frames[self.cur_frame]
+     defupdate(self):
+        if self.i < len(self.frames):
+            self.cur_frame = (self.cur_frame + 1) % len(self.frames)
+            self.image = pygame.transform.scale(self.frames[self.cur_frame], (90, 90))
+            self.i += 1
+        else:
+            self.kill()
+            board.on_click(board.c1)
+
+
+class Checkmark(pygame.sprite.Sprite):
+    def __init__(self, pos_x, pos_y):
+        super().__init__(checkmark_group, all_sprites)
+        self.image = pygame.transform.scale(load_image('checkmark.png'), (60, 45))
+        self.rect = self.image.get_rect().move(
+            5 + tile_width * pos_x, 30 + tile_height * pos_y)
 
 
 class Stone(pygame.sprite.Sprite):
@@ -367,14 +531,47 @@
         self.text = [0, need]
         self.rect = self.image.get_rect().move(
             10 + tile_width * pos_x, 10 + tile_height * pos_y)
+        self.x, self.y = pos_x, pos_y
 
 
 class Instrument(pygame.sprite.Sprite):
     def __init__(self, tile_type, pos_x, pos_y):
         super().__init__(instruments_group, all_sprites)
+        self.name = tile_type
         self.image = instrument_images[tile_type]
+        self.animation = instrument_animations[tile_type]
         self.rect = self.image.get_rect().move(
             630, 130 + 90 * pos_y)
+        self.active = False
+        self.used = False
+
+
+class InstrumentPad:
+    def __init__(self):
+        self.width, self.height = 1, 4
+        self.cell_size = 90
+        self.left, self.top = 630, 130
+        self.mouse_pos = (0, 0)
+        self.active_instrument = None
+
+    def get_cell(self, mouse_pos):
+        cell_x = (mouse_pos[0] - self.left) // self.cell_size
+        cell_y = (mouse_pos[1] - self.top) // self.cell_size
+        if cell_x < 0 or cell_x >= self.width or cell_y < 0 or cell_y >= self.height:
+            return None
+        return cell_x, cell_y
+
+    def get_click(self, mouse_pos):
+        self.mouse_pos = mouse_pos
+        cell = self.get_cell(mouse_pos)
+        if cell:
+            self.on_click(cell)
+
+    def on_click(self, cell):
+        if self.get_cell(self.mouse_pos) == cell:
+            if not self.active_instrument:
+                instrument_quadra[cell[1]].active = True
+                self.active_instrument = instrument_quadra[cell[1]]
 
 
 class Move:
@@ -432,6 +629,7 @@
 
 
 board = Board(8, 8, 10, 10, 75)
+instrument_pad = InstrumentPad()
 move_pad = Move(20)
 running = True
 while running:
@@ -442,14 +640,18 @@
             running = False
         if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
             board.get_click(event.pos)
-    board.horizontal_reduce()
-    board.vertical_reduce()
+            instrument_pad.get_click(event.pos)
+    # board.horizontal_reduce()
+    # board.vertical_reduce()
     draw_cell_field()
     draw_instruments()
     move_pad.show()
     write_statistic(('5', 10), ('6', 15), ('4', 20))
     game_result.check_moves()
+    animated_group.draw(screen)
+    animated_group.update()
+    checkmark_group.draw(screen)
     pygame.display.flip()
     screen.fill('black')
     clock.tick(FPS)
-terminate()
+terminate()
\ No newline at end of file
