Index: Magic_Minerals.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport sys\r\nimport os\r\nfrom copy import deepcopy\r\n\r\npygame.init()\r\nFPS = 50\r\nWIDTH = 1080\r\nHEIGHT = 720\r\nSTEP = 10\r\n\r\nfirst_time = True\r\n\r\n# группы спрайтов\r\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\r\npygame.display.set_caption('Magic Minerals')\r\nclock = pygame.time.Clock()\r\n\r\nall_sprites = pygame.sprite.Group()\r\nstones_group = pygame.sprite.Group()\r\nnecessary_stones = []  # список необходимых камней (объектов класса NecessaryStone)\r\nnecessary_stones_group = pygame.sprite.Group()\r\ninstruments_group = pygame.sprite.Group()\r\n\r\n\r\ndef load_image(name,  directory='stones', color_key=None):\r\n    full_name = os.path.join(directory, name)\r\n    try:\r\n        image = pygame.image.load(full_name)\r\n    except pygame.error as message:\r\n        print(f'В папке отсутствует файл {name}')\r\n        raise SystemExit(message)\r\n\r\n    if color_key is not None:\r\n        if color_key == -1:\r\n            color_key = image.get_at((0, 0))\r\n        image.set_colorkey(color_key)\r\n    else:\r\n        image = image.convert_alpha()\r\n    return image\r\n\r\n\r\ndef load_level(filename):\r\n    filename = os.path.join('stones', filename)\r\n    # читаем уровень, убирая символы перевода строки\r\n    with open(filename, 'r') as mapFile:\r\n        level_map = [line.strip() for line in mapFile]\r\n\r\n    # и подсчитываем максимальную длину\r\n    max_width = max(map(len, level_map))\r\n\r\n    # дополняем каждую строку пустыми клетками ('.')\r\n    return list(map(lambda x: x.ljust(max_width, '.'), level_map))\r\n\r\n\r\ndef generate_level(level):\r\n    x, y = None, None\r\n    for y in range(len(level)):\r\n        for x in range(len(level[y])):\r\n            Stone(level[y][x], x, y)\r\n    return x, y\r\n\r\n\r\ndef terminate():\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\n\r\ndef draw_cell_field():\r\n    board.render(screen)\r\n    stones_group.draw(screen)\r\n\r\n\r\ndef draw_instruments():\r\n    pygame.draw.rect(screen, pygame.Color('brown'), (630, 130, 90, 360), 0)\r\n    pygame.draw.rect(screen, pygame.Color('wheat'), (630, 130, 90, 360), 3)\r\n    for i in range(4):\r\n        pygame.draw.ellipse(screen, pygame.Color('lightsalmon'), (630, 130 + 90 * i, 90, 90), 0)\r\n        pygame.draw.ellipse(screen, pygame.Color('wheat'), (630, 130 + 90 * i, 90, 90), 2)\r\n        Instrument(instruments[i], 0, i)\r\n    instruments_group.draw(screen)\r\n\r\n\r\ndef to_statistic(stone_num, quantity):\r\n    for st in necessary_stones:\r\n        if st.tile_type == stone_num:\r\n            st.text[0] += quantity\r\n\r\n\r\ndef write_statistic(*stones):\r\n    text = ''\r\n    x, y = 0, 8\r\n    coeff = 10\r\n    global first_time\r\n    if first_time:\r\n        for stone in stones:\r\n            st = NecessaryStone(stone[0], x, y, stone[1])\r\n            necessary_stones.append(st)\r\n            text += ' ' * coeff + f'0/{stone[1]}'\r\n            x += 2\r\n            coeff = 19\r\n            first_time = False\r\n    else:\r\n        for stone in necessary_stones:\r\n            text += ' ' * coeff + f'{stone.text[0]}/{stone.text[1]}'\r\n            x += 2\r\n            coeff = 19\r\n    text = [text]\r\n    font = pygame.font.Font(None, 30)\r\n    text_coord = 650\r\n    necessary_stones_group.draw(screen)\r\n    for line in text:\r\n        string_rendered = font.render(line, 1, pygame.Color('white'))\r\n        text_rect = string_rendered.get_rect()\r\n        text_coord += 10\r\n        text_rect.top = text_coord\r\n        text_rect.x = 10\r\n        text_coord += text_rect.height\r\n        screen.blit(string_rendered, text_rect)\r\n\r\n\r\nstone_images = {\r\n    '0': load_image('tiger.png'),\r\n    '1': load_image('amber.png'),\r\n    '2': load_image('amethyst.png'), '3': load_image('diamond.png'),\r\n    '4': load_image('emerald.png'), '5': load_image('ruby.png'),\r\n    '6': load_image('sapphire.png'),\r\n}\r\n\r\ninstruments = ['pickaxe', 'drill', 'dynamite', 'lantern']\r\ninstrument_images = {}\r\n\r\nfor i in range(0, 7):\r\n    stone_images[str(i)] = pygame.transform.scale(stone_images[str(i)], (75, 75))\r\n\r\nfor ins in instruments:\r\n    instrument_images[ins] = load_image(f'{ins}.png', directory='assets/instruments')\r\n    instrument_images[ins] = pygame.transform.scale(instrument_images[ins], (90, 90))\r\n\r\n\r\ntile_width = tile_height = 75\r\n\r\n\r\nclass Board:\r\n    def __init__(self, width, height,\r\n                 left=10, top=10, cell_size=30):\r\n        self.width = width\r\n        self.height = height\r\n        self.board = load_level('level.txt')\r\n        self.cell_size = cell_size\r\n        self.left = left\r\n        self.top = top\r\n        self.c1 = (None, None)\r\n        self.c2 = (None, None)\r\n\r\n    def set_view(self, left, top, cell_size):\r\n        self.left = left\r\n        self.top = top\r\n        self.cell_size = cell_size\r\n\r\n    def render(self, screen):\r\n        for y in range(self.height):\r\n            for x in range(self.width):\r\n                if (x, y) == self.c1:\r\n                    pygame.draw.rect(screen, pygame.Color('lightgreen'),\r\n                                     (self.left + self.c1[0] * self.cell_size,\r\n                                      self.top + self.c1[1] * self.cell_size, self.cell_size, self.cell_size), 0)\r\n                if (x, y) == self.c2:\r\n                    pygame.draw.rect(screen, pygame.Color('pink'),\r\n                                     (self.left + self.c2[0] * self.cell_size,\r\n                                      self.top + self.c2[1] * self.cell_size, self.cell_size, self.cell_size), 0)\r\n                pygame.draw.rect(screen, pygame.Color('white'),\r\n                                 (self.left + x * self.cell_size,\r\n                                  self.top + y * self.cell_size,\r\n                                  self.cell_size, self.cell_size), 1)\r\n\r\n    def on_click(self, cell):\r\n        if self.c1 == (None, None) and self.c2 == (None, None):\r\n            self.c1 = cell\r\n        elif self.c1 != (None, None) and self.c2 == (None, None):\r\n            self.c2 = cell\r\n        else:\r\n            self.c1 = cell\r\n            self.c2 = (None, None)\r\n        if self.c1 != (None, None) and self.c2 != (None, None) and self.c1 != self.c2:\r\n            [st.kill() for st in stones_group]\r\n            c1, c2 = self.c1, self.c2\r\n            # for i, st in enumerate(stones_group):\r\n            #     if i == c1[0] * 8 + c1[1]:\r\n            #         st.kill()\r\n            #     if i == c2[0] * 8 + c2[1]:\r\n            #         st.kill()\r\n            if c1[1] == c2[1] and abs(c1[0] - c2[0]) == 1:\r\n                line1 = list(self.board[c1[1]])\r\n                stone1, stone2 = line1[c1[0]], line1[c2[0]]\r\n                if c1[0] < c2[0]:\r\n                    del line1[c1[0]]\r\n                    del line1[c2[0] - 1]\r\n                    line1.insert(c2[0] - 1, stone1)\r\n                    line1.insert(c1[0], stone2)\r\n                else:\r\n                    del line1[c2[0]]\r\n                    del line1[c1[0] - 1]\r\n                    line1.insert(c1[0] - 1, stone2)\r\n                    line1.insert(c2[0], stone1)\r\n                line1 = ''.join(line1)\r\n                self.board[self.c1[1]] = line1\r\n                self.horizontal_reduce()\r\n                self.vertical_reduce()\r\n            elif c1[0] == c2[0] and abs(c1[1] - c2[1]) == 1:\r\n                line1, line2 = list(self.board[c1[1]]), list(self.board[c2[1]])\r\n                stone1, stone2 = line1[c1[0]], line2[c2[0]]\r\n                del line1[c1[0]]\r\n                del line2[c2[0]]\r\n                line1.insert(c2[0], stone2)\r\n                line2.insert(c1[0], stone1)\r\n                line1, line2 = ''.join(line1), ''.join(line2)\r\n                self.board[c1[1]], self.board[c2[1]] = line1, line2\r\n                self.horizontal_reduce()\r\n                self.vertical_reduce()\r\n            move_pad.minus()\r\n\r\n    def get_cell(self, mouse_pos):\r\n        cell_x = (mouse_pos[0] - self.left) // self.cell_size\r\n        cell_y = (mouse_pos[1] - self.top) // self.cell_size\r\n        if cell_x < 0 or cell_x >= self.width or cell_y < 0 or cell_y >= self.height:\r\n            return None\r\n        return cell_x, cell_y\r\n\r\n    def get_click(self, mouse_pos):\r\n        cell = self.get_cell(mouse_pos)\r\n        if cell:\r\n            self.on_click(cell)\r\n\r\n    def horizontal_reduce(self):\r\n        i, j = 0, 0\r\n        while i < self.height:\r\n            del_list = []\r\n            while j < self.width:\r\n                cur_st = self.board[i][j]\r\n                del_list.append((i, j))\r\n                j += 1\r\n                if j == self.width:\r\n                    break\r\n                if self.board[i][j] == cur_st:\r\n                    while self.board[i][j] == cur_st:\r\n                        del_list.append((i, j))\r\n                        j += 1\r\n                        if j == self.width:\r\n                            break\r\n                    if len(del_list) >= 3:\r\n                        to_statistic(cur_st, len(del_list))\r\n                else:\r\n                    cur_st = self.board[i][j]\r\n                    del_list = []\r\n                if len(del_list) >= 3:\r\n                    tmp_line = list(self.board[i])\r\n                    for tpl in del_list:\r\n                        tmp_line[tpl[1]] = '0'\r\n                    tmp_line = ''.join(tmp_line)\r\n                    self.board[i] = tmp_line\r\n                    del_list = []\r\n            i += 1\r\n            j = 0\r\n\r\n    def vertical_reduce(self):\r\n        i, j = 0, 0\r\n        while j < self.height:\r\n            del_list = []\r\n            while i < self.width:\r\n                cur_st = self.board[i][j]\r\n                del_list.append((i, j))\r\n                i += 1\r\n                if i == self.height:\r\n                    break\r\n                if self.board[i][j] == cur_st:\r\n                    while self.board[i][j] == cur_st:\r\n                        del_list.append((i, j))\r\n                        i += 1\r\n                        if i == self.height:\r\n                            break\r\n                    if len(del_list) >= 3:\r\n                        to_statistic(cur_st, len(del_list))\r\n                else:\r\n                    cur_st = self.board[i][j]\r\n                    del_list = []\r\n                if len(del_list) >= 3:\r\n                    # tmp_line = list(self.board[i])\r\n                    for tpl in del_list:\r\n                        tmp_line = list(self.board[tpl[0]])\r\n                        tmp_line[tpl[1]] = '0'\r\n                        tmp_line = ''.join(tmp_line)\r\n                        self.board[tpl[0]] = tmp_line\r\n                    del_list = []\r\n            j += 1\r\n            i = 0\r\n\r\n\r\nclass Stone(pygame.sprite.Sprite):\r\n    def __init__(self, tile_type, pos_x, pos_y):\r\n        super().__init__(stones_group, all_sprites)\r\n        self.image = stone_images[tile_type]\r\n        self.rect = self.image.get_rect().move(\r\n            10 + tile_width * pos_x, 10 + tile_height * pos_y)\r\n\r\n\r\nclass NecessaryStone(pygame.sprite.Sprite):\r\n    def __init__(self, tile_type, pos_x, pos_y, need):\r\n        super().__init__(necessary_stones_group, all_sprites)\r\n        self.tile_type = tile_type\r\n        self.image = stone_images[tile_type]\r\n        self.text = [0, need]\r\n        self.rect = self.image.get_rect().move(\r\n            10 + tile_width * pos_x, 10 + tile_height * pos_y)\r\n\r\n\r\nclass Instrument(pygame.sprite.Sprite):\r\n    def __init__(self, tile_type, pos_x, pos_y):\r\n        super().__init__(instruments_group, all_sprites)\r\n        self.image = instrument_images[tile_type]\r\n        self.rect = self.image.get_rect().move(\r\n            630, 130 + 90 * pos_y)\r\n\r\n\r\nclass Move:\r\n    def __init__(self, n):\r\n        self.n = n\r\n\r\n    def minus(self):\r\n        self.n -= 1\r\n\r\n    def show(self):\r\n        pygame.draw.ellipse(screen, 'YellowGreen', (630, 10, 90, 90), 0)\r\n        pygame.draw.ellipse(screen, 'DarkGreen', (630, 10, 90, 90), 5)\r\n        text = [str(self.n)]\r\n        font = pygame.font.Font(None, 70)\r\n        text_coord = 17\r\n        for line in text:\r\n            string_rendered = font.render(line, 1, pygame.Color('DarkGreen'))\r\n            text_rect = string_rendered.get_rect()\r\n            text_coord += 10\r\n            text_rect.top = text_coord\r\n            text_rect.x = 645\r\n            text_coord += text_rect.height\r\n            screen.blit(string_rendered, text_rect)\r\n\r\n\r\nboard = Board(8, 8, 10, 10, 75)\r\nmove_pad = Move(20)\r\nrunning = True\r\nwhile running:\r\n    level_x, level_y = generate_level(board.board)\r\n    for event in pygame.event.get():\r\n        if event.type == pygame.QUIT:\r\n            running = False\r\n        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:\r\n            board.get_click(event.pos)\r\n    draw_cell_field()\r\n    draw_instruments()\r\n    move_pad.show()\r\n    write_statistic(('5', 10), ('6', 15), ('4', 20))\r\n    pygame.display.flip()\r\n    screen.fill('black')\r\n    clock.tick(FPS)\r\nterminate()\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Magic_Minerals.py b/Magic_Minerals.py
--- a/Magic_Minerals.py	(revision 183078c07f8ec13c655c2e32981555af1007ed4f)
+++ b/Magic_Minerals.py	(date 1641894131708)
@@ -1,7 +1,6 @@
 import pygame
 import sys
 import os
-from copy import deepcopy
 
 pygame.init()
 FPS = 50
@@ -10,6 +9,7 @@
 STEP = 10
 
 first_time = True
+victory = False
 
 # группы спрайтов
 screen = pygame.display.set_mode((WIDTH, HEIGHT))
@@ -17,27 +17,34 @@
 clock = pygame.time.Clock()
 
 all_sprites = pygame.sprite.Group()
+animated_group = pygame.sprite.Group()
 stones_group = pygame.sprite.Group()
-necessary_stones = []  # список необходимых камней (объектов класса NecessaryStone)
+necessary_stones = [] # список необходимых камней (объектов класса NecessaryStone)
 necessary_stones_group = pygame.sprite.Group()
 instruments_group = pygame.sprite.Group()
 
+loaded_images = {}
+
 
 def load_image(name,  directory='stones', color_key=None):
     full_name = os.path.join(directory, name)
-    try:
-        image = pygame.image.load(full_name)
-    except pygame.error as message:
-        print(f'В папке отсутствует файл {name}')
-        raise SystemExit(message)
+    if full_name not in loaded_images.keys():
+        try:
+            image = pygame.image.load(full_name)
+        except pygame.error as message:
+            print(f'В папке отсутствует файл {name}')
+            raise SystemExit(message)
 
-    if color_key is not None:
-        if color_key == -1:
-            color_key = image.get_at((0, 0))
-        image.set_colorkey(color_key)
-    else:
-        image = image.convert_alpha()
-    return image
+        if color_key is not None:
+            if color_key == -1:
+                color_key = image.get_at((0, 0))
+            image.set_colorkey(color_key)
+        else:
+            image = image.convert_alpha()
+        loaded_images[full_name] = image
+        return image
+    else:
+        return loaded_images[full_name]
 
 
 def load_level(filename):
@@ -69,6 +76,9 @@
 def draw_cell_field():
     board.render(screen)
     stones_group.draw(screen)
+    # animated_group.draw(screen)
+    # animated_group.update()
+    # [b.kill() for b in animated_group]
 
 
 def draw_instruments():
@@ -81,14 +91,14 @@
     instruments_group.draw(screen)
 
 
-def to_statistic(stone_num, quantity):
+def (stone_num, quantity):
     for st in necessary_stones:
         if st.tile_type == stone_num:
             st.text[0] += quantity
 
 
 def write_statistic(*stones):
-    text = ''
+    text = ""
     x, y = 0, 8
     coeff = 10
     global first_time
@@ -117,10 +127,15 @@
         text_rect.x = 10
         text_coord += text_rect.height
         screen.blit(string_rendered, text_rect)
+    count = 0
+    for stone in necessary_stones:
+        if stone.text[0] >= stone.text[1]:
+            count += 1
+    if count == len(necessary_stones):
+        game_result.victory()
 
 
 stone_images = {
-    '0': load_image('tiger.png'),
     '1': load_image('amber.png'),
     '2': load_image('amethyst.png'), '3': load_image('diamond.png'),
     '4': load_image('emerald.png'), '5': load_image('ruby.png'),
@@ -130,7 +145,7 @@
 instruments = ['pickaxe', 'drill', 'dynamite', 'lantern']
 instrument_images = {}
 
-for i in range(0, 7):
+for i in range(1, 7):
     stone_images[str(i)] = pygame.transform.scale(stone_images[str(i)], (75, 75))
 
 for ins in instruments:
@@ -152,6 +167,15 @@
         self.top = top
         self.c1 = (None, None)
         self.c2 = (None, None)
+        with open('stones/fall.txt', 'rt') as f:
+            file = f.readlines()
+        self.queue = list(file[0])
+        self.global_del_list = []
+
+    def next_in_queue(self):
+        next = self.queue[0]
+        del self.queue[0]
+        return next
 
     def set_view(self, left, top, cell_size):
         self.left = left
@@ -163,18 +187,26 @@
             for x in range(self.width):
                 if (x, y) == self.c1:
                     pygame.draw.rect(screen, pygame.Color('lightgreen'),
-                                     (self.left + self.c1[0] * self.cell_size,
-                                      self.top + self.c1[1] * self.cell_size, self.cell_size, self.cell_size), 0)
+ (self.left + self.c1[0] * self.cell_size,
+                                      self.top + self.c1[1] * self., self., self.), 0)
                 if (x, y) == self.c2:
                     pygame.draw.rect(screen, pygame.Color('pink'),
-                                     (self.left + self.c2[0] * self.cell_size,
-                                      self.top + self.c2[1] * self.cell_size, self.cell_size, self.cell_size), 0)
+ (self.left + self.c2[0] * self.cell_size,
+                                      self.top + self.c2[1] * self., self., self.), 0)
                 pygame.draw.rect(screen, pygame.Color('white'),
-                                 (self.left + x * self.cell_size,
+ (self.left + x * self.cell_size,
                                   self.top + y * self.cell_size,
                                   self.cell_size, self.cell_size), 1)
 
+        for lst in self.global_del_list:
+            for x, y in lst:
+                pygame.draw.rect(screen, pygame.Color('Khaki'),
+ (self.left + y * self.cell_size,
+                                  self.top + x * self.cell_size, self.cell_size, self.cell_size), 0)
+                boom = AnimatedSprite(load_image("boom.jpg"), 6, 5, x * self.cell_size, y * self.cell_size)
+
     def on_click(self, cell):
+        self.global_del_list = []
         if self.c1 == (None, None) and self.c2 == (None, None):
             self.c1 = cell
         elif self.c1 != (None, None) and self.c2 == (None, None):
@@ -254,9 +286,10 @@
                     cur_st = self.board[i][j]
                     del_list = []
                 if len(del_list) >= 3:
+                    self.global_del_list.append(del_list)
                     tmp_line = list(self.board[i])
                     for tpl in del_list:
-                        tmp_line[tpl[1]] = '0'
+                        tmp_line[tpl[1]] = self.next_in_queue()
                     tmp_line = ''.join(tmp_line)
                     self.board[i] = tmp_line
                     del_list = []
@@ -286,9 +319,10 @@
                     del_list = []
                 if len(del_list) >= 3:
                     # tmp_line = list(self.board[i])
+                    self.global_del_list.append(del_list)
                     for tpl in del_list:
                         tmp_line = list(self.board[tpl[0]])
-                        tmp_line[tpl[1]] = '0'
+                        tmp_line[tpl[1]] = self.next_in_queue()
                         tmp_line = ''.join(tmp_line)
                         self.board[tpl[0]] = tmp_line
                     del_list = []
@@ -296,6 +330,29 @@
             i = 0
 
 
+class AnimatedSprite(pygame.sprite.Sprite):
+    def __init__(self, sheet, columns, rows, x, y):
+        super().__init__(animated_group)
+        self.frames = []
+        self.cut_sheet(sheet, columns, rows)
+        self.cur_frame = 0
+        self.image = self.frames[self.cur_frame]
+        self.rect = self.rect.move(x, y)
+
+    def cut_sheet(self, sheet, columns, rows):
+        self.rect = pygame.Rect(0, 0, sheet.get_width() // columns,
+                                sheet.get_height() // rows)
+        for j in range(rows):
+            for i in range(columns):
+                frame_location = (self.rect.w * i, self.rect.h * j)
+                self.frames.append(sheet.subsurface(pygame.Rect(
+                    frame_location, self.rect.size)))
+
+    def update(self):
+        self.cur_frame = (self.cur_frame + 1) % len(self.frames)
+        self.image = self.frames[self.cur_frame]
+
+
 class Stone(pygame.sprite.Sprite):
     def __init__(self, tile_type, pos_x, pos_y):
         super().__init__(stones_group, all_sprites)
@@ -304,7 +361,7 @@
             10 + tile_width * pos_x, 10 + tile_height * pos_y)
 
 
-class NecessaryStone(pygame.sprite.Sprite):
+class (pygame.sprite.Sprite):
     def __init__(self, tile_type, pos_x, pos_y, need):
         super().__init__(necessary_stones_group, all_sprites)
         self.tile_type = tile_type
@@ -332,7 +389,7 @@
     def show(self):
         pygame.draw.ellipse(screen, 'YellowGreen', (630, 10, 90, 90), 0)
         pygame.draw.ellipse(screen, 'DarkGreen', (630, 10, 90, 90), 5)
-        text = [str(self.n)]
+        text = [str(self.n).rjust(2, ' ')]
         font = pygame.font.Font(None, 70)
         text_coord = 17
         for line in text:
@@ -343,24 +400,58 @@
             text_rect.x = 645
             text_coord += text_rect.height
             screen.blit(string_rendered, text_rect)
+
+
+class WinOrDefeat:
+    def __init__(self, moves):
+        self.moves = moves
+
+    def check_moves(self):
+        if self.moves == 0 and not victory:
+            self.defeat()
+
+    def defeat(self):
+        text = 'Неудача!'
+        font = pygame.font.Font(None, 200)
+        text_coord = 17
+        string_rendered = font.render(text, 1, pygame.Color('White'))
+        text_rect = string_rendered.get_rect()
+        text_rect.top = text_coord
+        text_rect.x = 10
+        screen.blit(string_rendered, text_rect)
+
+    def victory(self):
+        global victory
+        text = 'Изумительно!' if self.moves < 3 else 'Прелестно!'
+        font = pygame.font.Font(None, 200)
+        text_coord = 17
+        string_rendered = font.render(text, 1, pygame.Color('White'))
+        text_rect = string_rendered.get_rect()
+        text_rect.top = text_coord
+        text_rect.x = 10
+        screen.blit(string_rendered, text_rect)
+        victory = True
 
 
 board = Board(8, 8, 10, 10, 75)
 move_pad = Move(20)
 running = True
 while running:
+    game_result = WinOrDefeat(move_pad.n)
     level_x, level_y = generate_level(board.board)
     for event in pygame.event.get():
         if event.type == pygame.QUIT:
             running = False
         if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
             board.get_click(event.pos)
+    board.horizontal_reduce()
+    board.vertical_reduce()
     draw_cell_field()
     draw_instruments()
     move_pad.show()
     write_statistic(('5', 10), ('6', 15), ('4', 20))
+    game_result.check_moves()
     pygame.display.flip()
     screen.fill('black')
     clock.tick(FPS)
-terminate()
-
+terminate()
\ No newline at end of file
